# 엄격 모드
자바스크립트는 꽤 오랫동안 호환성 이슈 없이 발전해왔다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었다. 덕분에 기존에 작성한 코드를 망치지 않는 장점이 있으나 창시자들이 했던 실수나 불완전한 결정이 계속 남게 되는 단점이 있다. 

이런 상황은 ECMAScript5(ES5)가 등장하기 전인 2009년까지 지속되었다. 
ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생긴다. 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었다. 대신 use string라는 지시자를 통해 스크립트 전체가 모던한 방식으로 동작하도록 할 수 있다. 

### use strict 
한마디로 엄격모드이다. 
엄격한 parsing 및 error handling을 자발적으로 시행하도록 적용함으로써 일반적인 코딩 실수나 안전하지 않은 동작을 포착한다. 

- 장점 
    1. 디버깅이 쉬워진다.
    2. js 엔진의 최적화
    3. 발생 가능한 에러 예방 
```
"use strict";

// 이 코드는 모던한 방식으로 실행됩니다.
...
```

- use strict는 스크립트 최상단에 있어야 한다. 단, 함수 본문 맨 앞에 있을 수도 있다. 잘 안 쓰지만,, 
- use strict를 취소할 방법은 없다. 
- 브라우저 콘솔을 사용하는 경우 use strict가 적용되어 있지 않다. 

# nullish 병합 연산자 
??를 통해 '확정되어 있는' 변수를 찾을 수 있다.

ex)
```
let firstName = null;
let lastName = null;
let nickName = "바이올렛";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "익명의 사용자"); // 바이올렛
```

### '??'와 '||'의 차이
둘은 동작이 꽤 비슷하나 ||은 0을 falsey하게 인식하기 때문에 숫자 0를 다룰 때 매우 조심해야 한다.

ex)
```
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```
위의 예제에서 ||는 0을 false로 인식했기 때문에 100을 리턴하게 됐다. 
반면에 ??는 정확하게 null이나 undefined일 경우에만 100이 된다.

### nullish 병합 연산자의 우선순위 
?? 연산자는 우선순위가 낮기 때문에 ()와 같이 써야한다. 

# 심볼형 
> 유일한 식별자(unique identifier)를 만들고 싶을 때 사용한다. 
```
let id = Symbol();
```
> 또한 심볼을 만들 때 심볼 이름이라 불리는 설명을 붙일 수도 있다. 심볼 일므은 디버깅 시 매우 유용하게 쓰일 수 있다. 
```
let id = Symbol("id");
```

> 심볼은 똑같은 설명으로 여러개 만들어도 기본적으로 각 값들은 다르다. 
```
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
```

> 심볼은 문자형으로 자동 형 변환이 되지 않는다. 
```
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
```

### 심볼의 쓰임새
> 심볼은 정보 은닉 등에 쓰일 수 있다. (외부 코드에서 접근 불가능하고 값도 덮어쓰일 수 없도록 할 수 있다.)
```
let user = { // 서드파티 코드에서 가져온 객체
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // 심볼을 키로 사용해 데이터에 접근할 수 있습니다.
```
> 그런데 굳이 id를 쓰면 되는데 Symbol("id")를 사용한 걸까? 
  이유는 외부 제 3의 스크립트가 user를 식별해야 하는 상황이 벌어질 경우 충돌할 수도 있기 떄문이다. 

  심볼은 유일성이 보장되므로 식별자와 제 3의 스크립트에서 만든 식별자가 충돌하지 않는다. 

- Symbols in a literal 
> 객체 리터럴 {...}을 사용해 객체를 만든 경우, 대괄호를 사용해 심볼형 키를 만들어야 한다. 
```
let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // "id": 123은 안됨
};
```

- 심볼은 for...in에서 배제된다. 
```
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name과 age만 출력되고, 심볼은 출력되지 않습니다.
```
> 비슷한 원리로 Object.keys(user)에서도 키가 심볼인 프로퍼티는 배제된다. 
  단 Object.assign은 다르다. (심볼도 같이 할당할 수 있다.)

```
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

## 정리 
Symbol은 원시형 데이터로, 유일무이한 식별자를 만드는 데 사용된다. 
Symbol()을 호출하면 심볼을 만들 수 있다. 
심볼은 이름이 같아도 값이 항상 다르다.
심볼의 주요 사용 케이스는 다음과 같다.
1. 객체의 '숨김' 프로퍼티: 외부 스크립트나 라이브러리에 속한 객체에 새로운 프로퍼티를 추가해 주고 싶다면 심볼을 만들고, 이를 프로퍼티 키로 사용하면 된다. 
   for..in의 대상이 되지 않으므로 위도치 않게 프로퍼티가 수정되는 것을 미리 예방할 수 있다. -> 이런 특징을 이용하면 원하는 것을 객체 안에 은밀하게 숨길 수 있다.
2. 자바스크립트 내부에서 사용되는 시스템 심볼은 Symbol.*로 접근할 수 있다, 시스템 심볼을 이용하면 내장 메서드 등의 기본 동작을 입맛대로 변경할 수 있다. 
