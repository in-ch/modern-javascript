# 엄격 모드
자바스크립트는 꽤 오랫동안 호환성 이슈 없이 발전해왔다. 기존의 기능을 변경하지 않으면서 새로운 기능이 추가되었다. 덕분에 기존에 작성한 코드를 망치지 않는 장점이 있으나 창시자들이 했던 실수나 불완전한 결정이 계속 남게 되는 단점이 있다. 

이런 상황은 ECMAScript5(ES5)가 등장하기 전인 2009년까지 지속되었다. 
ES5에서는 새로운 기능이 추가되고 기존 기능 중 일부가 변경되었다. 기존 기능을 변경하였기 때문에 하위 호환성 문제가 생긴다. 그래서 변경사항 대부분은 ES5의 기본 모드에선 활성화되지 않도록 설계되었다. 대신 use string라는 지시자를 통해 스크립트 전체가 모던한 방식으로 동작하도록 할 수 있다. 

### use strict 
한마디로 엄격모드이다. 
엄격한 parsing 및 error handling을 자발적으로 시행하도록 적용함으로써 일반적인 코딩 실수나 안전하지 않은 동작을 포착한다. 

- 장점 
    1. 디버깅이 쉬워진다.
    2. js 엔진의 최적화
    3. 발생 가능한 에러 예방 
```
"use strict";

// 이 코드는 모던한 방식으로 실행됩니다.
...
```

- use strict는 스크립트 최상단에 있어야 한다. 단, 함수 본문 맨 앞에 있을 수도 있다. 잘 안 쓰지만,, 
- use strict를 취소할 방법은 없다. 
- 브라우저 콘솔을 사용하는 경우 use strict가 적용되어 있지 않다. 

# nullish 병합 연산자 
??를 통해 '확정되어 있는' 변수를 찾을 수 있다.

ex)
```
let firstName = null;
let lastName = null;
let nickName = "바이올렛";

// null이나 undefined가 아닌 첫 번째 피연산자
alert(firstName ?? lastName ?? nickName ?? "익명의 사용자"); // 바이올렛
```

### '??'와 '||'의 차이
둘은 동작이 꽤 비슷하나 ||은 0을 falsey하게 인식하기 때문에 숫자 0를 다룰 때 매우 조심해야 한다.

ex)
```
let height = 0;

alert(height || 100); // 100
alert(height ?? 100); // 0
```
위의 예제에서 ||는 0을 false로 인식했기 때문에 100을 리턴하게 됐다. 
반면에 ??는 정확하게 null이나 undefined일 경우에만 100이 된다.

### nullish 병합 연산자의 우선순위 
?? 연산자는 우선순위가 낮기 때문에 ()와 같이 써야한다. 

# 심볼형 
> 유일한 식별자(unique identifier)를 만들고 싶을 때 사용한다. 
```
let id = Symbol();
```
> 또한 심볼을 만들 때 심볼 이름이라 불리는 설명을 붙일 수도 있다. 심볼 일므은 디버깅 시 매우 유용하게 쓰일 수 있다. 
```
let id = Symbol("id");
```

> 심볼은 똑같은 설명으로 여러개 만들어도 기본적으로 각 값들은 다르다. 
```
let id1 = Symbol("id");
let id2 = Symbol("id");

alert(id1 == id2); // false
```

> 심볼은 문자형으로 자동 형 변환이 되지 않는다. 
```
let id = Symbol("id");
alert(id); // TypeError: Cannot convert a Symbol value to a string
```

### 심볼의 쓰임새
> 심볼은 정보 은닉 등에 쓰일 수 있다. (외부 코드에서 접근 불가능하고 값도 덮어쓰일 수 없도록 할 수 있다.)
```
let user = { // 서드파티 코드에서 가져온 객체
  name: "John"
};

let id = Symbol("id");

user[id] = 1;

alert( user[id] ); // 심볼을 키로 사용해 데이터에 접근할 수 있습니다.
```
> 그런데 굳이 id를 쓰면 되는데 Symbol("id")를 사용한 걸까? 
  이유는 외부 제 3의 스크립트가 user를 식별해야 하는 상황이 벌어질 경우 충돌할 수도 있기 떄문이다. 

  심볼은 유일성이 보장되므로 식별자와 제 3의 스크립트에서 만든 식별자가 충돌하지 않는다. 

- Symbols in a literal 
> 객체 리터럴 {...}을 사용해 객체를 만든 경우, 대괄호를 사용해 심볼형 키를 만들어야 한다. 
```
let id = Symbol("id");

let user = {
  name: "John",
  [id]: 123 // "id": 123은 안됨
};
```

- 심볼은 for...in에서 배제된다. 
```
let id = Symbol("id");
let user = {
  name: "John",
  age: 30,
  [id]: 123
};

for (let key in user) alert(key); // name과 age만 출력되고, 심볼은 출력되지 않습니다.
```
> 비슷한 원리로 Object.keys(user)에서도 키가 심볼인 프로퍼티는 배제된다. 
  단 Object.assign은 다르다. (심볼도 같이 할당할 수 있다.)

```
let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123
```

## 정리 
Symbol은 원시형 데이터로, 유일무이한 식별자를 만드는 데 사용된다. 
Symbol()을 호출하면 심볼을 만들 수 있다. 
심볼은 이름이 같아도 값이 항상 다르다.
심볼의 주요 사용 케이스는 다음과 같다.
1. 객체의 '숨김' 프로퍼티: 외부 스크립트나 라이브러리에 속한 객체에 새로운 프로퍼티를 추가해 주고 싶다면 심볼을 만들고, 이를 프로퍼티 키로 사용하면 된다. 
   for..in의 대상이 되지 않으므로 위도치 않게 프로퍼티가 수정되는 것을 미리 예방할 수 있다. -> 이런 특징을 이용하면 원하는 것을 객체 안에 은밀하게 숨길 수 있다.
2. 자바스크립트 내부에서 사용되는 시스템 심볼은 Symbol.*로 접근할 수 있다, 시스템 심볼을 이용하면 내장 메서드 등의 기본 동작을 입맛대로 변경할 수 있다. 


# 참조에 의한 객체 복사
> 객체와 원시 타입의 근본적인 차이 중 하나는 객체는 '참조에 의해' 저장되고 복사되고 원시값(string, number,...) 등은 값 그대로 저장, 할당되고 복사된다.

> 그렇다면 객체 복사는 어떤 식으로 복사될까? 
ex) 
```
const user = {
  name: "John"
}
let admin = user; // 참조값을 복사함
```
![스크린샷 2023-01-02 오후 10 59 40](https://user-images.githubusercontent.com/49556566/210241281-dc600b91-bda1-4131-ac57-fb460f6cd419.png)
![스크린샷 2023-01-02 오후 10 59 43](https://user-images.githubusercontent.com/49556566/210241287-30386e86-d835-47d6-85b1-07d823f61d79.png)

단, 객체 비교 시 ==와 ===는 모두 동일하게 동작한다. 
```
let a = {};
let b = a; // 참조에 의한 복사

alert( a == b ); // true, 두 변수는 같은 객체를 참조합니다.
alert( a === b ); // true
```

그러나 두 객체 모두 비어있다면 독립된 객체이기 떄문에 일치, 동등 비교하면 false가 나오게 된다.
```
let a = {};
let b = {}; // 독립된 두 객체

alert( a == b ); // false
```

### 객체의 복사 
> 그렇다면 객체가 할당된 변수를 복사하면 동일한 객체에 대한 참조 값이 하나 더 만들어지는데 이렇게 하는 게 아니라 객체를 그대로 복사하고 싶다면 어떻게 해야할까? 
  Object.assign을 사용하면 된다 .
```
let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
```

### 깊은 복사
> 만약에 객체 안에 또다른 객체가 있다라고 한다면 user[key]의 각 값을 검사하면서, 그 값이 객체인 경우 객체의 구조도 복사해주는 반복문을 사용해야 한다.
  이런 방식을 '깊은 복사'라고 한다.

### 요약
> 객체는 참조에 의해 할당되고 복사된다. 변수엔 '객체' 자체가 아닌 메모리상의 주소인 '참조'가 저장된다. 따라서 객체가 할당된 변수를 복사하거나 함수의 인자로 
  넘길 땐 객체가 아닌 객체의 참조가 복사된다. 
  그리고 복사된 참조를 ㅣㅇ용한 모든 작업(프로퍼티 추가, 삭제 등)은 동일한 객체를 대상으로 이뤄진다.
  객체의 진짜 복사본을 만드려면 얉은 복사를 가능하게 해주는 Object.assign이나 '깊은 복사'를 해야 한다. (얕은 복사는 중첩 객체를 처리하지 못하기 때문에) 
